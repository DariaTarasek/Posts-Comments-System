package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"OzonTestTask/internal/graphql/generated"
	"OzonTestTask/internal/model"
	"context"
	"fmt"
	"strconv"
	"time"
)

// ID is the resolver for the id field.
func (r *commentResolver) ID(ctx context.Context, obj *model.Comment) (string, error) {
	return strconv.Itoa(obj.ID), nil
}

// PostID is the resolver for the postId field.
func (r *commentResolver) PostID(ctx context.Context, obj *model.Comment) (string, error) {
	return strconv.Itoa(obj.PostID), nil
}

// ParentCommentID is the resolver for the parentCommentId field.
func (r *commentResolver) ParentCommentID(ctx context.Context, obj *model.Comment) (*string, error) {
	if obj.ParentCommentID == nil {
		return nil, nil
	}
	strParentCommentID := strconv.Itoa(*obj.ParentCommentID)
	return &strParentCommentID, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *commentResolver) CreatedAt(ctx context.Context, obj *model.Comment) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// Replies is the resolver for the replies field.
func (r *commentResolver) Replies(ctx context.Context, obj *model.Comment) ([]*model.Comment, error) {
	replies, err := r.CommentService.GetReplies(ctx, obj.ID)
	if err != nil {
		return nil, fmt.Errorf("не удалось получить ответы на комментарий: %v", err)
	}

	result := make([]*model.Comment, len(replies))
	for i := range replies {
		result[i] = &replies[i]
	}
	return result, nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, author string, areCommentsAllowed bool) (*model.Post, error) {
	post := &model.Post{
		Title:              title,
		Content:            content,
		Author:             author,
		AreCommentsAllowed: areCommentsAllowed,
	}
	if err := r.PostService.CreatePost(ctx, post); err != nil {
		return nil, fmt.Errorf("не удалось создать пост: %v", err)
	}
	return post, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, postID string, parentID *string, author string, content string) (*model.Comment, error) {
	intID, err := strconv.Atoi(postID)
	if err != nil {
		return nil, fmt.Errorf("не удалось преобразовать id поста в int: %v", err)
	}
	var parent *int
	if parentID != nil {
		intParentID, err := strconv.Atoi(*parentID)
		if err != nil {
			return nil, fmt.Errorf("не удалось преобразовать parentID: %v", err)
		}
		parent = &intParentID
	}

	comment := &model.Comment{
		PostID:          intID,
		ParentCommentID: parent,
		Author:          author,
		Content:         content,
	}

	err = r.CommentService.CreateComment(ctx, comment)
	if err != nil {
		return nil, fmt.Errorf("не удалось создать комментарий: %v", err)
	}

	return comment, nil
}

// ID is the resolver for the id field.
func (r *postResolver) ID(ctx context.Context, obj *model.Post) (string, error) {
	return strconv.Itoa(obj.ID), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *postResolver) CreatedAt(ctx context.Context, obj *model.Post) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// Comments is the resolver for the comments field.
func (r *postResolver) Comments(ctx context.Context, obj *model.Post, limit *int, offset *int) (*model.PaginatedComments, error) {
	defaultLimit := 5
	defaultOffset := 0
	if limit == nil {
		limit = &defaultLimit
	}
	if offset == nil {
		offset = &defaultOffset
	}

	comments, totalPages, err := r.CommentService.GetCommentsByPost(ctx, obj.ID, *limit, *offset)
	if err != nil {
		return nil, fmt.Errorf("не удалось получить комментарии для поста: %v", err)
	}
	resultComments := make([]*model.Comment, len(comments))
	for i := range comments {
		resultComments[i] = &comments[i]
	}
	return &model.PaginatedComments{
		Comments:   resultComments,
		TotalPages: totalPages,
	}, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	posts, err := r.PostService.GetAllPosts(ctx)
	if err != nil {
		return nil, fmt.Errorf("не удалось получить список постов: %v", err)
	}
	result := make([]*model.Post, len(posts))
	for i := range posts {
		result[i] = &posts[i]
	}
	return result, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	idInt, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("не удалось преобразовать id поста в int: %v", err)
	}
	post, err := r.CommentService.GetPostByID(ctx, idInt)
	if err != nil {
		return nil, fmt.Errorf("не удалось получить пост: %v", err)
	}
	return post, nil
}

// Replies is the resolver for the replies field.
func (r *queryResolver) Replies(ctx context.Context, id string) ([]*model.Comment, error) {
	intID, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	replies, err := r.CommentService.GetReplies(ctx, intID)
	if err != nil {
		return nil, fmt.Errorf("не удалось получить ответы на комментарий: %v", err)
	}

	result := make([]*model.Comment, len(replies))
	for i := range replies {
		result[i] = &replies[i]
	}
	return result, nil
}

// Comment returns generated.CommentResolver implementation.
func (r *Resolver) Comment() generated.CommentResolver { return &commentResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Post returns generated.PostResolver implementation.
func (r *Resolver) Post() generated.PostResolver { return &postResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type commentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
